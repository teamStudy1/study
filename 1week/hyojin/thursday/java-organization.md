- 하나의 쓰레드는 한 개의 일을 하는데 멀티 쓰레드는 동시에 여러 일을 할 수 있게 함
- 파이썬과 노드는 단일 스레드라고 한다!
- 코틀린은 자바의 쓰레드를 좀 더 가볍게 사용할 수 있도록 만든게 코루틴
- 21에서 생긴 virtual thread는 쓰레드의 경량화 개념
- 17에서는 jvm이 os에게 자원을 요청해서 할당 받아 사용
- 코루틴은 물리적인 스레드를 점유 받은 뒤 이론 상 무한정하게 늘릴 수 있도록 만든 가상 스레드이다
- 커널이 다르다는 것은 명령하는 방법이 다르다는 것
- 환경변수는 커맨드와 연결되어 있음. git을 쳤을 때 어떤 프로그램이 응답해야 하는지도 이런 원리

# java

```markdown
* java의 실행 과정 :
1. java 소스 코드(.java 파일)을 작성한다.
2. 컴파일러(javac)를 사용하여 바이트코드(.class 파일)로 변환한다.
3. jvm(java virtual machine)이 .class 파일을 실행한다.
4. jvm은 바이트코드를 해석하여 os에서 실행 가능한 기계어로 변환한다.
5. 실행 결과를 출력하거나 다른 연산을 수행한다.

* java 실행 방식 이해하기

* java의 실행 방식은 “컴파일 + 인터프리터” 방식을 사용한다.
* 이는 java 코드가 먼저 바이트코드로 변환된 후 jvm에 의해 해석 실행되는 것을 의미한다.

주요 개념 :
- 컴파일(compile) : .java -> .class로 변환하기 위해 (javac 사용) jvm이 고급 언어를 이해하기 위함.
- 바이트코드(Bytecode) : jvm에서 실행 가능한 중간 코드
- jvm(java virtual Machine) : 바이트코드를 OS에 맞는 기계어로 변환하여 실행.
- jit(just-in-Time) 컴파일러 : 실행 중 바이트코드를 네이티브 코드로 변환하여 성능 향상.

```

```markdown
JVM 메모리 구조
JVM 메모리 구조는 크게 5개의 영역으로 나뉨

1. Method Area
- 메서드 영역
- 클래스 정보
- static 변수
- 상수 풀 (Constant Pool) 저장

2. Heap
- 힙
- 객체 및 인스턴스 변수 저장

3. Stack
- 스택
- 지역 변수, 메서드 호출 시 생성되는 프레임 저장

4. PC Register
- pc 레지스터
- 현재 실행 중인 JVM 명령어의 주소 저장

5. Native Method Stack
- 네이티브 메소드 스택
- JNI (Java Native Interface)에서 사용하는 네이티브 코드 실행 공간
- OS 통신 혹은 고성능 연산과 같은 작업을 위해 자바보다 적합한 언어로 개발된 코드가 저장되는 공간
```

```markdown
리터릴이란
소스 코드에 직접 작성된 값 자체를 의미한다
예를 들어 int a = 100 에서 100은 정수 리터럴이고
String str = "hi"; 에서 "hi"는 문자열 리터럴이다
리터럴은 변수에 저장되기 전에 순수한 값을 의미한다

변수는 데이터를 저장하기 위한 메모리 공간을 참조하는 이름
프로그램이 데이터를 다룰 때 메모리 어딘가에 값을 저장하고 그 위치를 이름으로 쉽게 불러올 수 잇음
number는 메모리 주소와 매칭되어 0x001을 사람이 표현하기 쉽게 number라고 표현
```

- 컴파일(compile) : java→.class로 변환하기 위해 javac를 사용함. jvm이 고급 언어를 이해하기 위함
- 바이트 코드 (Bytecode) : jvm에서 실행 가능한 중간 코드
- jvm(java virtual Machine) : 바이트 코드를 OS에 맞는 기계어로 변환하여 실행
- jit(just-in-time) 컴파일러 : 실행 중 바이트코드를 네이티브 코드로 변환하여 성능 향상

```java
public static void main(String[] args) {
	// Scanner 객체는 힙 메모리에 저장
	// 참조 변수는 스택에 저장
	Scanner sc = new Scanner(System.in); 
	System.out.println("이름을 입력해주세요");
	String name = sc.nextLine();
}
```

- 코드에 외부 라이브러리 클래스 추가하는 법 배움
- nextLine()을 제외하고는 sc의 next관련 메서드에서는 마지막에 \n을 따로 인식함 그래서 nextLine() 을 한번 더 입력 받은 것과 비슷한 효과가 나타남

# Primitive Type (기본형)과 Reference Type(참조형)

### Primitive Type (기본형)

= 원시 자료형

- 기본형 데이터는 값 자체가 스택 영역에 저장됨
- 변수는 메서드 실행 동안만 메모리에 존재, 메서드가 종료되면 자동으로 제거
- 기본형 데이터는 메모리 사용이 효율적이고 접근 속도가 빠름

<aside>
💡

int number = 10을 선언하면 number라는 변수 이름과 값 10이 스택에 바로 기록됨
이렇게 하면 메모리 사용이 효율적이고 변수의 생명 주기가 메서드 실행 범위 내로 제한

GC (Garbage Collection)의 관리 대상이 되지 않음

</aside>

```java
int num = 10;
```

### Reference Type (참조형)

- 참조형 데이터(String, 배열, 객체)는 메모리 주소를 스택 영역에 저장함
- 실제 데이터는 힙 영역에 저장
- 참조형 데이터는 메서드가 종료되어도 참조하는 객체가 남아 있을 수 있음

<aside>
💡

String text = “hello”;를 선언하면 스택에는 text라는 변수와 힙 내에 “hello” 객체의 주소가 저장됨
힙에는 hello 문자열 객체가 생성

</aside>

- GC가 필요하지 않은 객체를 제거함
- 객체를 재사용하거나 공유할 수 있게 해줌
- 힙에 저장된 데이터는 GC에 의해 필요 없어질 때 정리됨

# 자바 콜스택

- 스택 프레임
    - 스택으로 동작할 수 있는 공간을 가짐


# String pool의 역활

- String은 참조형 but java는 문자열 리터럴 (예: “hello”)을 힙 내 String Pool(또는 String constant pool)이라는 특수 영역에 저장
- 동일한 문자열을 재사용해 메모리를 절약하기 위한 최적화

<aside>
💡

String text1 = “hello”와 String text2 = “hello” 같은 String pool 내의 “hello” 객체를 참조
text1 == text2 같음

반면 new String(”hello”) 처럼 명시적으로 객체를 생성할 경우 String pool 밖에 별도의 힙 객체가 만들어져 중복 사용됨 text1 ≠ text3

</aside>

- jvm 메모리 효율성을 높이고 문자열 비교 (==로 참조 비교시) 성능을 개선함
- String pool에 저장된 문자열은 불변이므로 값 수정 시 새로운 객체가 생성됨


# 형변환 (Type Conversion)

- 프로그래밍에서 데이터 타입을 다른 데이터 타입으로 변경하는 과정
- 암시적 형변환과 명시적 형변환으로 나뉨

### 암시적 형변환 (Implicate Type Conversion)

- 작은 범위의 데이터 타입에서 큰 범위의 데이터 타입으로 자동 변환되는 과정을 의미
- (int → long)의 경우 데이터 손실이 발생하지 않음

```
/*
    *  명시적 형변환 (Explicit Type Conversion)
    *  정의: 큰 범위의 데이터 타입에서 작은 범위의 데이터 타입으로 변환할 때, 프로그래머가 직접 변환을 지정해야 하는 과정이다.
    *  (double -> int) 이 경우, 데이터 손실이 발생할 수 있다.

        // 출력
        System.out.println("암시적 형변환 결과(doubleVal): " + doubleVal);
        System.out.println("명시적 형변환 결과(iVal): " + iVal);

        /*
         * 주의: 명시적 형변환은 데이터 손실 가능성이 있다.
         * 데이터 타입 선택 시, 값의 범위와 필요 정확도를 고려해야 한다.
         *
         * 참고 : 과거에는 컴퓨터의 용량이 작기 때문에 바이트 수가 중요하게 생각되었다.
         * 그러나 요즘 컴퓨터의 용량은 매우 많기 때문에 바이트 수를 과거보다는 덜 중요하게 생각한다.
         *
         * 그렇다면 무조건 큰 데이터 타입으로 작성하면 되는 것 아닐까?
         * 프로그램에서는 데이터를 처리하는 기본 단위가 있으며, 이 기본 단위를 기반으로 연산 구조가 설계되어 있다.
         * 무조건 큰 데이터 타입을 사용하는 것이 항상 좋은 선택은 아닙니다. 큰 데이터 타입은 더 많은 메모리를 차지하고,
         * CPU의 캐시를 비효율적으로 사용할 수 있어 성능 저하를 초래할 수 있다
         *
         * 자료형의 기본 단위
         * 정수형 -> int
         * 실수형 -> double
         *
         */
```

# 부동소수점과 정밀도

- float, double은 IEEE 754 부동소수점 표준을 따름

### 부동소수점 (Floating-point)

- 실수를 부호, 지수, 가수로 표현
- float : 32비트 (부호 1비트, 지수 8비트, 가수 23비트)
- double : 64비트 (부호 1비트, 지수 11비트, 가수 52비트)

### 구조

- 부호 비트 (sing bit) : 숫자가 양수인지 음수인지 표현
- 지수 (Exponent) : 숫자의 크기(스케일을 결정), 2의 거듭제곱으로 표현
- 가수 (mantissa or significand) : 숫자의 유효 숫자 (소수점 이하 포함)을 나타낸다

### 이진 표현의 한계

- 10진수 소스(예 0.1)은 이진수로 정확히 표현되지 않음 (무한 소수). 근삿값 방식으로 저장되며 float보다 double이 더 높은 정밀도를 제공함

### 부동 소수점 오차

- 연산 (덧셈, 비교 등) 시 미세한 오차가 누적될 수 있음

### 실무

- 실수 비교 시 “==” 대신 오차 범위를 사용 권장 (예: Math.abs(a-b) < 0.0001)
- 정밀도가 중요한 경우 Bigdecimal 클래스 사용

# Operator

- 데이터 타입이 표현할 수 있는 값의 범위를 초과하거나 미달할 때 발생하는 현상
- 예기치 않은 버그의 원인이 될 수 있음

### 오버 플로우

- 최대값을 초과하면 해당 데이터 타입의 최솟값으로 순환
- 예) byte 타입 (최대 127) 에서 127 + 1 = -128

### 언더플로우

- 최솟값보다 작아지면 해당 데이터 타입의 최댓값으로 순환
- 예) byte타입 (최소 -128)에서 -128 -1 = 127

# 증감 연산자

- 전위 (++a) : 연산 전에 값을 1 증가 시킨 후 다른 연산에 사용
- 후위 (a++) : 다른 연산에 현재 값을 먼저 사용한 후 값을 1 증가 시킴
- 복잡한 식에서는 실행 순서과 결과를 좌우하므로 명확하게 이해하는 것이 중요함