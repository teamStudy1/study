# 📌 Java if문과 단축 평가 (Short-Circuit Evaluation)

## 1. if 문 실행 과정

- JVM 스택에서 **조건식**을 계산한다.
- 조건식 결과(`boolean`)이 **스택에 저장**된다.
- 조건식이 `true` → 해당 코드 블록으로 **jump**
- 조건식이 `false` → **다음 분기**로 이동

---

## 2. Short-Circuit Evaluation (단축 평가)

조건식 최적화를 위한 평가 방식.

### 🔹 AND 연산 (`&&`)

- 두 피연산자가 모두 **true**일 때만 결과가 true
- **첫 번째 피연산자가 false**이면, 두 번째는 **평가하지 않음** (중단)

### 🔹 OR 연산 (`||`)

- 두 피연산자 중 **하나라도 true**이면 결과가 true
- **첫 번째 피연산자가 true**이면, 두 번째는 **평가하지 않음** (중단)

➡️ **불필요한 계산을 줄여 성능 최적화**

---

## 3. 메모리 관점

- 조건식의 변수는 **JVM 스택**에 저장된다.
- 블록 내 **지역 변수**도 스택 프레임에 추가된다.
- **중첩 if문**이 많을수록:
    - 스택 사용량 증가
    - 코드 가독성 저하

예를 들어

`int age = 25;`

`String discount;`

`System.*out*.println("비효율족인 조건 순서: ");`

`long startTime = System.*nanoTime*();`

`if (age <= 19) {    discount = "학생 할인 가능";}`

`else {    discount = "학생 할인 불가능";}`

이러한 코드가 있다고 하면 if(age < = 19) 는

boolean status = age < = 19 (false) 이런 식으로 들어가서

if(false) { } 이런 식으로 된다.

---

## ✅ 정리

- `if` 조건식은 JVM 스택에서 계산 후 boolean 값으로 분기한다.
- `&&`, `||` 연산은 **단축 평가**로 불필요한 연산을 줄인다.
- 스택 메모리 특성을 고려해 **중첩 if문은 최소화**하는 것이 좋다.

# 📌 Java switch 문의 깊은 개념: 메모리 최적화

## 1. switch 문 실행 방식

- `switch`는 **JVM에서 jump table로 컴파일**되어 실행된다.
- `if-else` 체인보다 **빠른 분기 처리** 가능.
- **식의 값**은 JVM 스택에 저장된다.
- `case` 값은 **메서드 영역(Method Area)의 상수 풀(Constant Pool)** 과 비교된다.
- `break` 문이 없는 경우 → **fall-through**로 다음 case 실행이 이어진다.

---

## 2. Jump Table

- `switch`를 효율적으로 구현하기 위한 핵심 기법.
- 각 **case 값 → 실행 코드 주소**를 매핑한 테이블을 생성.
- 분기 시 테이블의 인덱스를 이용해 O(1)로 실행 코드 접근.

### 예시

```java
switch (2) {
    case 1: System.out.println("hi");
    case 2: System.out.println("hhh");
    // case=2 이므로 jump table의 2번 인덱스 참조 → 바로 실행
}

```

---

## 3. JDK 17 이후 개선

- **Switch 표현식**
    - `case ->` 구문을 사용해 값을 반환 가능.

    ```java
    String result = switch(day) {
        case MONDAY -> "Start";
        case FRIDAY -> "Weekend soon";
        default -> "Midweek";
    };
    
    ```

- **패턴 매칭 (preview)**
    - 객체 타입에 따라 분기 가능.

    ```java
    switch (obj) {
        case String s -> System.out.println("String: " + s);
        case Integer i -> System.out.println("Integer: " + i);
        default -> System.out.println("Other");
    }
    
    ```


---

## 4. 메모리 효율성

- case 수가 많을수록 **jump table 크기 증가**
- 하지만 분기 성능은 **항상 O(1)** 유지
- JVM은 상황에 따라:
    - **tableswitch** (연속된 값 → 메모리 사용 ↑, 속도 ↑)
    - **lookupswitch** (드문드문한 값 → 메모리 절약)

      두 가지 명령어를 선택해 최적화한다.


---

## ✅ 정리

- `switch`는 jump table을 활용하여 **빠른 분기 처리** 가능.
- JDK 17부터는 **표현식·패턴 매칭**으로 활용도가 크게 증가.
- 메모리와 속도는 `tableswitch` / `lookupswitch` 전략으로 자동 최적화된다.

# 📌 Java for문 동작과 메모리 구조

## 1. 메모리 동작 과정

1. **반복 제어 변수 생성**
    - `for`문 시작 시, 반복 제어 변수(`i`, `dan`, `num` 등)가 **JVM 스택 프레임**에 생성된다.
2. **조건 검사 & 실행**
    - 조건식이 `true` → 본문 실행
    - 조건식이 `false` → 반복 종료
3. **증감식 수행**
    - 변수 값 변경 후 다시 조건 검사를 반복
4. **반복 종료**
    - 반복이 끝나면 **for문 관련 스택 프레임 제거**, 다음 코드로 이동

---

## 2. 성능 최적화 관점

### 🔹 1) 불필요한 연산 제거

- 조건식에서 반복적으로 호출되는 연산은 **초기식에서 미리 계산**하는 것이 좋다.

```java
int len = arr.length;       // 배열 길이를 미리 저장
for (int i = 0; i < len; i++) {
    // arr.length를 매번 호출하지 않음
}

```

➡️ 조건식에서 매번 `arr.length`를 읽는 비용을 줄여 **미세한 성능 향상**

---

### 🔹 2) JIT(Just-In-Time) 컴파일러 최적화

- JVM의 **JIT 컴파일러**는 반복문을 실행 중에 분석하고, 자주 반복되는 패턴을 최적화한다.
    - **루프 전개 (Loop Unrolling)**: 반복 횟수를 줄이기 위해 여러 반복을 한 번에 묶어 실행
    - **루프 불변식 코드 이동 (Loop-Invariant Code Motion)**: 반복마다 값이 변하지 않는 계산을 루프 밖으로 이동
    - **벡터화 (Vectorization)**: 반복문을 CPU SIMD 명령어로 변환해 병렬 실행
- 덕분에, 소스 코드에서 단순한 반복문 최적화는 신경 쓸 필요가 줄어듦.

---

## ✅ 정리

- `for`문은 반복 제어 변수를 스택에 생성하고, 조건 → 실행 → 증감 과정을 반복한다.
- 조건식에서 **불필요한 연산을 줄이면** 미세한 최적화 가능하다.
- JIT 컴파일러가 **반복문 최적화(루프 전개, 불변식 이동, 벡터화 등)**를 수행하여 실행 속도를 개선한다.

# 📌 Java while문 동작과 메모리 구조

## 1. 메모리 동작 과정

1. **변수 생성**
    - `while` 문 시작 시, 조건식에 사용되는 변수(`count`, `limit` 등)가 **JVM 스택 프레임**에 저장된다.
2. **조건 검사 & 실행**
    - 조건식이 `true` → 본문 실행
    - 조건식이 `false` → 반복 종료
3. **반복 종료**
    - 조건이 거짓이 되면, `while` 관련 스택 프레임이 제거되고 **다음 코드로 이동**

---

## 2. 성능 최적화 관점

### 🔹 1) 조건식 계산 최소화

- 조건식에서 불필요한 연산을 줄이는 것이 중요하다.

```java
// 비효율적인 코드
while (count <= calculateLimit()) { ... }

// 효율적인 코드
int limit = calculateLimit();
while (count <= limit) { ... }

```

➡️ 매 반복마다 `calculateLimit()` 호출 → 성능 저하

➡️ 미리 변수에 저장 → 반복 성능 개선

---

### 🔹 2) 무한 루프 주의

- `while (true)`는 종료 조건이 없으므로 **무한 반복** 발생.
- `break` 문을 활용해 **안전한 종료 조건**을 명시하는 것이 권장된다.

```java
while (true) {
    if (exitCondition) break;
}

```

---

### 🔹 3) JIT 컴파일러 최적화

- JVM의 **JIT(Just-In-Time) 컴파일러**는 `while` 루프를 실행 중 최적화한다.
    - **루프 전개 (Loop Unrolling)**: 반복 횟수를 줄이기 위해 여러 회차를 한 번에 묶어서 실행
    - **루프 불변식 코드 이동**: 매번 변하지 않는 계산을 루프 밖으로 이동
    - **벡터화(Vectorization)**: 반복을 CPU SIMD 명령어로 변환해 병렬 실행
- 결과적으로 개발자가 작성한 단순 `while`문도 **실행 성능이 크게 개선**된다.

---

## ✅ 정리

- `while` 문은 조건 변수를 스택에 저장하고, 조건 검사 → 실행을 반복한다.
- 조건식에서 불필요한 계산을 제거하는 것이 성능 최적화의 핵심.
- `while(true)`는 반드시 `break`와 함께 사용해야 안전하다.
- JIT 컴파일러가 루프 최적화를 수행해 실행 속도를 개선한다.

# 📌Java 메서드 동작과 성능, 단일 책임 원칙

## 1. 메서드의 기본 구조와 동작

- **메서드**는 특정 작업을 수행하는 코드 블록이며, JVM의 **스택(stack) 영역**에서 관리된다.
- 메서드 호출 시:
    - 새로운 **스택 프레임(Stack Frame)**이 생성되어 스택에 **push** 된다.
    - 스택 프레임에는 **매개변수, 지역 변수, 리턴 주소** 등이 저장된다.
- 메서드 실행 종료 시:
    - 스택 프레임이 스택에서 **pop** 되어 제거된다.
- **장점**
    - 메모리 관리 용이
    - **재귀 호출** 가능
    - 디버깅 시 **호출 스택 추적** 가능

---

## 2. 메서드와 성능: JIT 컴파일러 & 인라이닝

- 메서드 호출 시에는 **스택 프레임을 쌓고 제거하는 오버헤드**가 발생한다.
- 하지만 현대 JVM은 **JIT(Just-In-Time) 컴파일러**를 통해 이 비용을 최적화한다.
- JIT의 역할:
    - 자주 실행되는 코드(Hot Spot)를 **실시간으로 기계어로 번역**
    - 실행 속도를 크게 향상
- **주요 최적화 기법: 인라이닝(Inlining)**
    - 작은 메서드를 호출하는 대신, **메서드 본문을 직접 삽입**
    - 호출 오버헤드 제거 → **성능 최적화**
    - 단, 너무 큰 메서드는 인라이닝 대상에서 제외됨

---

## 3. 단일 책임 원칙 (SRP: Single Responsibility Principle)

- 메서드(또는 클래스)는 **단 하나의 책임**만 가져야 한다.
- 즉, 변경해야 하는 이유가 **오직 하나**여야 한다.

### 🎯 SRP의 진짜 목적

1. **가독성 및 유지보수성 향상**
    - 코드가 간결하고 명확해져 이해와 수정이 쉬워진다.
2. **테스트 용이성**
    - 기능 단위가 분리되어 단위 테스트 작성이 간단해진다.
3. **재사용성 증가**
    - 범용적인 메서드는 다른 곳에서도 쉽게 활용 가능.
4. **부수적 효과 → 성능 최적화 가능**
    - 메서드가 작고 단순하면 JIT 컴파일러가 **인라이닝 최적화**를 적용하기 쉬움.

---

## ✅ 정리

- 메서드는 **스택 프레임 단위**로 관리되며, 호출 시 push / 종료 시 pop 된다.
- **JIT 컴파일러**와 **인라이닝**이 메서드 호출 비용을 최적화한다.
- *SRP(단일 책임 원칙)**은 성능이 아니라 **좋은 설계와 유지보수성**을 위한 원칙이다.
- 성능 향상은 SRP 설계가 가져다주는 **부수적 효과**일 뿐이다.